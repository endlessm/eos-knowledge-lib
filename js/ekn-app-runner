#!/usr/bin/env gjs

const Endless = imports.gi.Endless;
const EosKnowledgeSearch = imports.EosKnowledgeSearch;
const Lang = imports.lang;
const System = imports.system;

// We don't import this till we need it to keep the search provider fast.
let EosKnowledge = null;

if (ARGV.length < 2) {
    printerr("Run this script by passing it an app ID and a gresource file");
    System.exit(1);
}

const Application = new Lang.Class({
    Name: 'Application',
    GTypeName: 'EknApplication',
    Extends: Endless.Application,

    _init: function (props) {
        this.parent(props);
        this._presenter = null;
        this._activation_timestamp = null;
        this._search_provider = new EosKnowledgeSearch.SearchProvider();
    },

    vfunc_dbus_register: function(connection, path) {
        this.parent(connection, path);
        this._search_provider.export(connection, path);
        return true;
    },

    vfunc_dbus_unregister: function(connection, path) {
        this.parent(connection, path);
        this._search_provider.unexport(connection, path);
    },

    vfunc_startup: function() {
        this.parent();

        var domain = this.application_id.split('.').pop();
        // FIXME: we need to do some XDG_DATA_DIR searching for the database
        EosKnowledgeSearch.Engine.get_default().content_path = '/endless/share/ekn/data/' + domain;

        this._search_provider.connect('load-page', function (launcher, model, query, timestamp) {
            this._activation_timestamp = timestamp;
            this.activate();
            this._activation_timestamp = null;
            let results = this._search_provider.get_results();
            let more_results_callback = this._search_provider.get_more_results_callback();
            this._presenter.activate_search_result(model, query, results, more_results_callback);
        }.bind(this));

        this._search_provider.connect('load-query', function (launcher, query, timestamp) {
            this._activation_timestamp = timestamp;
            this.activate();
            this._activation_timestamp = null;
            this._presenter.search(query);
        }.bind(this));
    },

    vfunc_activate: function () {
        this.parent();

        if (EosKnowledge === null)
            EosKnowledge = imports.gi.EosKnowledge;

        if (this._presenter === null)
            this._presenter = EosKnowledge.get_presenter_for_resource(this, ARGV[1]);

        if (this._activation_timestamp !== null) {
            this._presenter.view.present_with_time(this._activation_timestamp);
        } else {
            this._presenter.view.present();
        }
    },

    vfunc_window_removed: function(win) {
        if (this._presenter.view === win) {
            this._presenter = null;
        }
        this.parent(win);
    },
});

let app = new Application({
    application_id: ARGV[0],
    inactivity_timeout: 12000,
});
// Gio assumes the first argument of the array is the name of the program being
// invoked. This is standard, but not done in gjs. So we stick ekn-app-runner to
// beginning of our arg list. We remove the two command line arguments handled in
// this script which we do not want to pass on to gapplication default handler.
app.run(['ekn-app-runner'].concat(ARGV.slice(2)));
