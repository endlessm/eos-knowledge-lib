fragment_downloaded_cb({"fragment": "Customizing the fonts and colors \nDetermining the content structure \nCreating a permanent shard for the sets \nPerhaps the most obvious thing to refine is the use of default fonts and colors in the rendered posts. We want to change these in our case to better reflect the style of the original site. \nThe way we do this is with the set_custom_scss method of the BlogArticle format. Each article format has its own default CSS theme. You can customize certain variables in the theme while largely sticking to the default. \nHere s what the custom SCSS looks like for customizing the font \nEach of these variables governs a font used for a particular purpose in the rendered asset. In our case we ll stick with Source Sans as the font just as the original blog does. \nWe also want to customize the color scheme to look more like the original blog. Here s some SCSS to do that \nJust as with the fonts these are variables specific to the BlogArticle s default theme. \nPutting it all together we add the following lines to our ingester in the same place where we set all the metadata on the post asset \nThe import _default brings in the default theme for BlogArticle. We can add custom SCSS rules to do further customization after the import line but we re not going to do that in this example. You can also leave out the import line if you want to start from scratch and write your own theme. \nRe run the ingester and view the hatch with Hatch Previewer you should see the effects of our customizations in the rendered HTML and also in the embedded CSS when you click the Flip button. \nThere s one last thing we have to do before being ready to use the content in an app. Most kinds of app experiences that we can build with the tools offered by the modular framework rely on organizing the content into some kind of categories. As promised in a previous part of the walkthrough it s time to learn more about how categories are represented in this toolkit s database format. \nFrom the user s point of view there are only collections of content which we call sets. Sets have metadata just like the assets that we ve stored in the hatch so far for example a title or a thumbnail image. The biggest difference is that sets aren t stored in hatches and aren t ingested instead they are created by the app author. Sets can be displayed in many different ways depending on their metadata and the app s UI. Sets can also be part of other sets and they can be marked as featured although the meaning of featured depends on how the app s UI interprets it. \nFrom the database s point of view each asset set image blog post or other content is tagged with any number of string identifiers. These identifiers are called tags and aren t visible to the user. \nSets have a metadata property called childTags which is an array of tag strings. Whichever tags are named in that property are considered to be part of the set. So on the UI side of things a set may contain articles from one or more tags and tags may be in one or more sets or not used in any set at all. \nNOTE Categories tags and even sets are overloaded terms they can mean a lot of different things in different contexts. The way they re used here is quite different from the way they re used in Wordpress for example. \nIt s best to think of the modular framework s sets and tags as a starting point not as an ending point or a particular categorization scheme that your app is forced into. As a tool and combined with different UI modules it s flexible enough to implement many different kinds of categorization schemes. \nSet assets are usually provided in a separate shard from the rest of the content. We call this a permanent shard. It s a common use case in apps to rotate content out in an update when it becomes old and at the same time rotate new content in and these shards are called in contrast ephemeral shards. \nThe categorization scheme for our app is going to work like this \nNow in Hatch Previewer we can scroll the left panel all the way down to see a list of tags along with how many articles use them. Remember when we first wrote the ingester we prefixed the tags of the latter kind with tag so we could tell them apart later. \nWe ll merge featured sets with only one post into one generic Blog Posts set for the purposes of this walkthrough and create a featured set from a few free form tags that have lots of posts associated with them. Normally we would not do this since we d have more content and the number of posts in each set will change anyway as new content rotates in and out but for this purpose it s nice not to have sets with lone articles in them. \nThe featured sets will be \nAt least in the hatch at the time this tutorial was written. \nWe ll also choose some of the free form tags to be non featured sets. For these it doesn t matter if they have only a lone post associated with them. They won t show up on the main menu only as tags at the bottom of articles. For example we ll create a Copyright Reform set covering the tags tag copyright reform tag eu copyright reform and tag fixcopyright. \nWe ll write a Basin manifest for the permanent shard and use Basin to create it. The manifest looks something like this \nThis shows one example each of a featured set and a non featured set. EknSetObject is a magic tag that the frontend requires for now it must be added manually. \nUsing Basin to convert the manifest into a shard is simple \nCompare this to how we created a shard earlier. To create this shard we ll use the Basin tool itself instead of basin hatch. The basin hatch tool uses Basin under the hood. The Basin manifest is the lowest level description of what goes into a shard and if you are writing more complicated apps you can write a tool similar to basin hatch that converts from some higher level format into a Basin manifest and uses Basin under the hood to create the shard. \n", "url": "tutorial/shard.html#page-description"});